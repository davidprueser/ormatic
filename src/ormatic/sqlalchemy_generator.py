from __future__ import annotations

import logging
from typing import TextIO, Dict, Any, List, Type, Optional, TYPE_CHECKING

import sqlalchemy
from sqlalchemy import Column, ForeignKey, Table
from sqlalchemy.orm import relationship, registry

from .dao import DataAccessObject
from .field_info import FieldInfo, RelationshipInfo, CustomTypeInfo

if TYPE_CHECKING:
    from .ormatic import ORMatic, WrappedTable

logger = logging.getLogger(__name__)


class SQLAlchemyGenerator:
    """
    A class for generating SQLAlchemy declarative mappings from ORMatic models.
    This class writes the tables generated by ORMatic to a file that serves as an SQL database interface.
    """

    def __init__(self, ormatic: ORMatic):
        """
        Initialize the SQLAlchemyGenerator with a reference to the ORMatic instance.

        :param ormatic: The ORMatic instance that created this SQLAlchemyGenerator.
        """
        self.ormatic = ormatic

    def to_sqlalchemy_file(self, file: TextIO):
        """
        Generate a Python file with SQLAlchemy declarative mappings from the ORMatic models.

        :param file: The file to write to
        """
        # Write imports
        self._write_imports(file)

        # Write registry
        file.write("# SQLAlchemy registry\n")
        file.write("mapper_registry = registry()\n\n")

        # Write classes
        for clazz, wrapped_table in self.ormatic.class_dict.items():
            self._write_class(file, wrapped_table)

    def _write_imports(self, file: TextIO):
        """
        Write the necessary imports to the file.

        :param file: The file to write to
        """
        file.write("# Generated by SQLAlchemyGenerator\n\n")
        file.write("from sqlalchemy import Column, ForeignKey, Integer, String, Float, Boolean, DateTime, Enum, JSON\n")
        file.write("from sqlalchemy.ext.declarative import declarative_base\n")
        file.write("from sqlalchemy.orm import relationship, registry\n")
        file.write("from typing import Optional, List, Dict, Any\n")

        # Import original classes
        for clazz in self.ormatic.class_dict.keys():
            file.write(f"from {clazz.__module__} import {clazz.__name__}\n")

        # Import DataAccessObject
        file.write("from ormatic.dao import DataAccessObject\n")

    def _write_class(self, file: TextIO, wrapped_table: WrappedTable):
        """
        Write a class definition to the file.

        :param file: The file to write to
        :param wrapped_table: The WrappedTable to write
        """
        clazz = wrapped_table.clazz
        tablename = wrapped_table.tablename

        # Write class declaration
        file.write(f"\n\nclass {tablename}(Base, DataAccessObject[{clazz.__name__}]):\n")
        file.write(f"    __tablename__ = '{tablename.lower()}'\n\n")

        # Write primary key
        file.write(f"    {wrapped_table.primary_key_name} = Column(Integer, primary_key=True)\n")

        # Write polymorphic discriminator if needed
        if wrapped_table.is_root_of_non_empty_inheritance_structure:
            file.write(f"    {wrapped_table.polymorphic_on_name} = Column(String(255))\n")
            file.write(f"    __mapper_args__ = {{\n")
            file.write(f"        'polymorphic_on': {wrapped_table.polymorphic_on_name},\n")
            file.write(f"        'polymorphic_identity': '{clazz.__module__}.{clazz.__name__}'\n")
            file.write(f"    }}\n")
        elif wrapped_table.parent_class:
            file.write(f"    __mapper_args__ = {{\n")
            file.write(f"        'polymorphic_identity': '{clazz.__module__}.{clazz.__name__}',\n")
            file.write(f"        'inherits': {wrapped_table.parent_class.tablename}\n")
            file.write(f"    }}\n")

        # Write columns
        for column in wrapped_table.columns:
            file.write(f"    {column.name} = {self._format_column(column)}\n")

        # Write relationships
        for rel_info in wrapped_table.one_to_one_relationships:
            file.write(f"    {rel_info.field_info.name} = {self._format_relationship(rel_info, is_one_to_many=False)}\n")

        for rel_info in wrapped_table.one_to_many_relationships:
            file.write(f"    {rel_info.field_info.name} = {self._format_relationship(rel_info, is_one_to_many=True)}\n")

        # Write custom types
        for custom_type in wrapped_table.custom_types:
            file.write(f"    {custom_type.field_info.name} = {self._format_custom_type(custom_type)}\n")

    def _format_column(self, column: Column) -> str:
        """
        Format a column for writing to the file.

        :param column: The column to format
        :return: A string representation of the column
        """
        args = []

        # Add column type
        try:
            if hasattr(column.type, 'python_type'):
                try:
                    python_type = column.type.python_type
                    if python_type == int:
                        args.append("Integer")
                    elif python_type == float:
                        args.append("Float")
                    elif python_type == str:
                        args.append("String(255)")
                    elif python_type == bool:
                        args.append("Boolean")
                    else:
                        args.append(f"String(255)  # Unknown type: {column.type}")
                except NotImplementedError:
                    # Handle case where python_type is not implemented
                    args.append(self._get_column_type_from_class(column.type))
            else:
                args.append(self._get_column_type_from_class(column.type))
        except Exception as e:
            # Fallback to String if all else fails
            args.append(f"String(255)  # Error determining type: {e}")

        # Add foreign keys
        if column.foreign_keys:
            for fk in column.foreign_keys:
                args.append(f"ForeignKey('{fk.target_fullname}')")

        # Add nullable
        if column.nullable:
            args.append("nullable=True")

        return f"Column({', '.join(args)})"

    def _get_column_type_from_class(self, column_type) -> str:
        """
        Get the column type from the class name.

        :param column_type: The column type
        :return: A string representation of the column type
        """
        type_name = column_type.__class__.__name__
        if type_name == 'Integer':
            return "Integer"
        elif type_name == 'Float':
            return "Float"
        elif type_name == 'String':
            return "String(255)"
        elif type_name == 'Boolean':
            return "Boolean"
        elif type_name == 'DateTime':
            return "DateTime"
        elif type_name == 'Enum':
            return "Enum"
        elif type_name == 'JSON':
            return "JSON"
        else:
            return f"String(255)  # Unknown type: {type_name}"

    def _format_relationship(self, rel_info: RelationshipInfo, is_one_to_many: bool) -> str:
        """
        Format a relationship for writing to the file.

        :param rel_info: The relationship info to format
        :param is_one_to_many: Whether this is a one-to-many relationship
        :return: A string representation of the relationship
        """
        args = []

        # Add target class
        target_class = rel_info.field_info.type.__name__ + "DAO"
        args.append(f"'{target_class}'")

        # Add back_populates if available
        if hasattr(rel_info.relationship, 'back_populates') and rel_info.relationship.back_populates:
            args.append(f"back_populates='{rel_info.relationship.back_populates}'")

        # Add foreign keys
        if hasattr(rel_info.relationship, 'foreign_keys') and rel_info.relationship.foreign_keys:
            fk_names = [f"[{rel_info.foreign_key_name}]"]
            args.append(f"foreign_keys={', '.join(fk_names)}")

        # Add uselist for one-to-many relationships
        if is_one_to_many:
            args.append("uselist=True")
        else:
            args.append("uselist=False")

        return f"relationship({', '.join(args)})"

    def _format_custom_type(self, custom_type: CustomTypeInfo) -> str:
        """
        Format a custom type for writing to the file.

        :param custom_type: The custom type info to format
        :return: A string representation of the custom type
        """
        return f"Column(JSON, nullable={custom_type.field_info.optional})"
