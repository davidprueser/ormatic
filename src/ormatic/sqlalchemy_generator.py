from __future__ import annotations

import logging
import os
from typing import TextIO, Dict, Any, List, Type, Optional, TYPE_CHECKING

import jinja2
import sqlalchemy
from sqlalchemy import Column, ForeignKey, Table
from sqlalchemy.orm import relationship, registry

from .dao import DataAccessObject
from .field_info import FieldInfo, RelationshipInfo, CustomTypeInfo

if TYPE_CHECKING:
    from .ormatic import ORMatic, WrappedTable

logger = logging.getLogger(__name__)


class SQLAlchemyGenerator:
    """
    A class for generating SQLAlchemy declarative mappings from ORMatic models.
    This class writes the tables generated by ORMatic to a file that serves as an SQL database interface.
    Uses Jinja2 templates for code generation.
    """

    env: jinja2.Environment
    """
    The environment to use with jinja2.
    """

    ormatic: ORMatic
    """
    The ORMatic instance that created this SQLAlchemyGenerator.
    """

    def __init__(self, ormatic: ORMatic):
        """
        Initialize the SQLAlchemyGenerator with a reference to the ORMatic instance.

        :param ormatic: The ORMatic instance that created this SQLAlchemyGenerator.
        """
        self.ormatic = ormatic

        # Set up Jinja2 environment
        template_dir = os.path.join(os.path.dirname(__file__), "..", "..",'templates')
        self.env = jinja2.Environment(
            loader=jinja2.FileSystemLoader(template_dir),
            trim_blocks=True,
            lstrip_blocks=True
        )

        # Register formatting functions
        self.env.globals['column_format'] = self._format_column
        self.env.globals['relationship_format'] = self._format_relationship
        self.env.globals['custom_type_format'] = self._format_custom_type

    def to_sqlalchemy_file(self, file: TextIO):
        """
        Generate a Python file with SQLAlchemy declarative mappings from the ORMatic models.

        :param file: The file to write to
        """
        # Load the template
        template = self.env.get_template('sqlalchemy_model.py.jinja')

        # Prepare class imports
        module_imports = set()
        for clazz in self.ormatic.class_dict.keys():
            module_imports |= {clazz.__module__}

        # Render the template
        output = template.render(
            wrapped_tables=self.ormatic.class_dict.values(),
            module_imports=module_imports
        )

        # Write the output to the file
        file.write(output)

    def _format_column(self, column: Column) -> str:
        """
        Format a column for writing to the file.

        :param column: The column to format
        :return: A string representation of the column
        """
        args = []
        # Add column type
        try:
            if hasattr(column.type, 'python_type'):
                try:
                    python_type = column.type.python_type
                    print(f"Column {column.name} has python_type: {python_type}")
                    if python_type == int:
                        args.append("Integer")
                    elif python_type == float:
                        args.append("Float")
                    elif python_type == str:
                        args.append("String(255)")
                    elif python_type == bool:
                        args.append("Boolean")
                    elif str(python_type).startswith("<enum "):
                        # Handle enum types
                        print(f"Enum type detected for column {column.name}: {python_type}")
                        args.append(f"Enum({python_type.__module__}.{python_type.__name__})")
                    else:
                        print(f"Unknown python_type: {python_type}")
                        args.append("String(255)")
                        unknown_type_comment = f"# Unknown type: {column.type}"
                except NotImplementedError:
                    # Handle case where python_type is not implemented
                    print(f"NotImplementedError for python_type of column {column.name}")
                    column_type_result = self._get_column_type_from_class(column.type)
                    if isinstance(column_type_result, tuple):
                        args.append(column_type_result[0])
                        unknown_type_comment = column_type_result[1]
                    else:
                        args.append(column_type_result)
                        unknown_type_comment = None
            else:
                print(f"Column {column.name} does not have python_type")
                column_type_result = self._get_column_type_from_class(column.type)
                if isinstance(column_type_result, tuple):
                    args.append(column_type_result[0])
                    unknown_type_comment = column_type_result[1]
                else:
                    args.append(column_type_result)
                    unknown_type_comment = None
        except Exception as e:
            # Fallback to String if all else fails
            print(f"Error determining type for column {column.name}: {e}")
            args.append("String(255)")
            unknown_type_comment = f"# Error determining type: {e}"

        # Add foreign keys
        if column.foreign_keys:
            for fk in column.foreign_keys:
                args.append(f"ForeignKey('{fk.target_fullname}')")

        # Add nullable
        if column.nullable:
            args.append("nullable=True")

        column_str = f"Column({', '.join(args)})"

        # Append comment at the end of the line if it exists
        if 'unknown_type_comment' in locals() and unknown_type_comment:
            column_str = f"{column_str} {unknown_type_comment}"

        return column_str

    def _get_column_type_from_class(self, column_type):
        """
        Get the column type from the class name.

        :param column_type: The column type
        :return: A string representation of the column type or a tuple of (type, comment)
        """
        type_name = column_type.__class__.__name__
        print(f"Column type: {type_name}, {column_type}")
        if type_name == 'Integer':
            return "Integer"
        elif type_name == 'Float':
            return "Float"
        elif type_name == 'String':
            return "String(255)"
        elif type_name == 'Boolean':
            return "Boolean"
        elif type_name == 'DateTime':
            return "DateTime"
        elif type_name == 'Enum':
            if hasattr(column_type, 'python_type'):

                return f"Enum({column_type.python_type.__module__}.{column_type.python_type.__name__})"
            else:
                return "Enum"
        elif type_name == 'JSON':
            return "JSON"
        else:
            return ("String(255)", f"# Unknown type: {type_name}")

    def _format_relationship(self, rel_info: RelationshipInfo, is_one_to_many: bool) -> str:
        """
        Format a relationship for writing to the file.

        :param rel_info: The relationship info to format
        :param is_one_to_many: Whether this is a one-to-many relationship
        :return: A string representation of the relationship
        """
        args = []

        # Add target class
        target_class = rel_info.field_info.type.__name__ + "DAO"
        args.append(f"'{target_class}'")

        # Add back_populates if available
        if hasattr(rel_info.relationship, 'back_populates') and rel_info.relationship.back_populates:
            args.append(f"back_populates='{rel_info.relationship.back_populates}'")

        # Add foreign keys
        if hasattr(rel_info.relationship, 'foreign_keys') and rel_info.relationship.foreign_keys:
            fk_names = [f"[{rel_info.foreign_key_name}]"]
            args.append(f"foreign_keys={', '.join(fk_names)}")
        # For one-to-many relationships, specify the foreign key column
        elif is_one_to_many:
            # Use the foreign_key_name from the relationship info
            fk_name = rel_info.foreign_key_name
            # Add the foreign key argument
            args.append(f"foreign_keys='[{target_class}.{fk_name}]'")

        # Add uselist for one-to-many relationships
        if is_one_to_many:
            args.append("uselist=True")
        else:
            args.append("uselist=False")

        return f"relationship({', '.join(args)})"

    def _format_custom_type(self, custom_type: CustomTypeInfo) -> str:
        """
        Format a custom type for writing to the file.

        :param custom_type: The custom type info to format
        :return: A string representation of the custom type
        """
        return f"Column(JSON, nullable={custom_type.field_info.optional})"
